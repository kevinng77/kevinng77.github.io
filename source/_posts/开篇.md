---
title: 计算机程序艺术TAOCP笔记(一)
date: 2020-12-10
author: Kevin 吴嘉文
subtitle: ''
description: ''
keywords: 
language: cn
timezone: ''
categories:
- 理论分析
tags:
- TAOCP
- algorithm|算法
- 计算机程序艺术
mathjax: true
toc: true
comments: 基础加密算法分析
---



# 开篇：关于这本书和算法

> （我）阅读这本书主要是为了理解计算机程序实现算法整个过程，一个只能表示0和1的机器，是如何高效的进行一系列运算，最后得到我们所提问题的结果。算法优化不仅应该停留在数学层面上的优化，也应该针对算法实现的过程进行优化。而今科技日新月异，传统计算机被摩尔定律等条件限制了发展的速度，希望能从本书中获得一些启发来把握新科技技术的优势（如量子计算机）使算法能够以最高效的方式运行。
>
> 这系列博客将用来记录我阅读中遇到的重点信息，个人笔记，或者有趣的题目:) 。你可以通过标签TAOCP 或 计算机程序艺术 找到他们。
>
> 本文参考《计算机程序艺术》第3版 国防工业出版社 及《Knuth D. - The art of computer programming. Volume 1-AW (1968) 》，对于中文版书籍与英文原著表达不一处，均已原著为准。

<!--more-->

## 特别的阅读流程

没有什么比具有逻辑思维的前言更能吸引一位热爱计算机程序的读者，以下是这本书前言中的一份阅读流程建议。看完这部分后我竟然有种想要通宵好几天一口气读完它的冲动！

![计算机程序设计艺术第一卷高清中文版](/img/开篇/计算机程序设计艺术第一卷高清中文版.jpg)


然后我就随手写了一下代码，用来加深对阅读流程的理解哈。
```python
N = 1
while N <= 12:
    章 = N
    if 对本章感兴趣:
        for 节 in 章:
            if 第一次阅读本节且本节以*开头:
                你可以选择 continue
            if 你爱数学:
                校验这一节中的数学推导，并把错误告诉作者
                for 习题 in 关于习题的说明中给出的提示做本节的练习题:
                    做
                    对答案 if 有答案
                if 累了:
                    睡觉
                    break
            else:
                如果这一章充满了数学推导，你最好略去不读。但你应该熟悉这一节的基本结果。
                这些基本结果通常在开始处附近叙述，或者在困难部分的末尾用斜体字叙述
    else:
        if N <= 2:
            本章挺重要，还是大致看一看
        else:
            N += 1
            if N in (3,5,7,9,11):
                进入下一卷
恭喜你，来说服你的朋友购买第1卷，并开始阅读他吧

```

### 习题分数

书中习题会有对应的分数来提示读者该题的难度，我也会在文中附上这些信息，具体如下：

分数：解释
00：一个极其容易的问题,如果你已理解正文的内容,就可能立即做出回答。 这样一道题几乎总是可以“眉头一披”就把它做出。
10：一个简单的问题。它要求你去思考刚刚学过的内容,但绝不意味着是困 难的。你应当有能力在顶多一分钟之内就把它做出。在获得解答的过程 中可能要用到笔和纸。
20：一个普通的问题。它检查你对正文内容的基本理解,但你可能需要十五 或二十分钟才能完整地回答它。
30：一个中等难度或中等复杂的问题。这个题目可能需要两个小时以上的 工作才能令人满意地解决。或者甚至更长时间,如果电视机在开着的 话。
40：确实是一个十分困难或咒长的问题。在学校里, 它将适合于作为一个学 期的课程设计。一个学生应当有能力在相当长的时间里来解决它,但这 个解不会是平凡的。
50：就作者在编写本书时所知,这是一个还未令人满意地解决的问题,尽管已 经有很多人做了尝试。如果你已经找到了这样- -个问题的答案,你应当把他发表出来

![image-20201215112933020](/img/开篇/image-20201215112933020.png)



### 算法的定义

《Knuth D. - The art of computer programming. Volume 1-AW (1968) 》将算法定义为一个四元组 $$\{(Q,I,\Omega,f)\}$$，四个变量分别表示计算状态，输入，输出及计算规则。其中，$Q$包含 $I$和$\Omega$，$f$是从$Q$到自身的一个函数， $$\forall q \in \Omega, f(q) = q$$，（因为$\Omega$为输出集）。

集合 $I$ 中的每一个输入 $x$ 定义一个计算序列 $x_{0}, x_{1},$ $x_{2}, \cdots$ 如下 :
$$
x_{0}=x \quad \text { 及 } \quad \text { 对于 } k \geqslant 0, \quad x_{k+1}=f\left(x_{k}\right)
$$
如果 $k$ 是使 $x_{k}$ 在 $\Omega$ 中的最小的整数，就说计算序列在 $k$ 步中终止，而且在此种情况下，说从 $x$ 产生出输出 $x_{k} $。 (注意,如果 $x_{k}$ 在 $\Omega$ 中,则 $x_{k+1}$ 也是。因为在这样的情况下，$x_{k+1}=x_{k}$。 某些计算序列可能永不终止；一个算法是对于 $I$ 中所有的 $x$ 在有限多步中终 止的计算方法。



### 算法的能行性

能行的算法（或称有效的算法）是指它的所有运算必须是充分基本的，在原则上人用笔和张都能在有限时间内精确的完成的。设计具有能行性的算法相当于对算法的概念加上限制，使得它仅涉及初等的运算。



## 题8. [M 25]算法的能行性

题：通过描述等式( 3$)$ 中的 $\theta_{j}, \phi_{j}, a_{j}, b_{j},$ 给出计算正整数 $m$ 和 $n$ 的最大公因子的一个 “能行的”形式算法。令输人由串 $a^{m} b^{n}$ 表示,即 $m$ 个 $a$ 后边跟着 $n$ 个 $b_{\circ}$ 

答：
$$
\begin{aligned}
&\text { 命 } A=\{a, b, c\}, N=5 \circ \text { 这个算法将以字符串 } a^{\operatorname{gcd}(m, n)} \text { 结束。 }\\
&\begin{array}{cccccl}
j & \theta_{j} & \phi_{j} & b_{j} & a_{j} & \text { 备注}\\
0 & a b & (\text { 空 }) & 1 & 2 & \text { 删掉一个 } a \text { 和一个 } b \text { ,若无 a 或 b 则转到 } 2 \\
1 & (\text { 空 }) & c & 0 & 0 & \text { 把 } c \text { 加到左端,返回到 } 0 \\
2 & a & b & 2 & 3 & \text { 把所有 } a \text { 变成 } b \\
3 & c & a & 3 & 4 & \text { 把所有 } c \text { 变成 } a \\
4 & b & b & 0 & 5 & \text { 如果还剩有 } b \text { ,则重复 }
\end{array}
\end{aligned}
$$
具有能行性的算法可能可以很好的解释计算机程序如如何实现一个具体算法的，理解这点可以更好的根据计算机的某些特性来实现算法的优化。在答案中的标志分别表示， $j$ ：计算步骤 ，$ \theta_{j}$ ：原串（string）， $ \phi_{j} $ ：代替原串的串， $ b_{j}$ ：如果有原串，那么运行第 $b_j$ 步骤，  $  a_{j}$：如果没有原串，那么运行第 $a_j$ 步骤。如果理解了这些符号的含义，即使没有右边的备注，你也应该能够想象到整个算法的一笔一划是怎么实现的。



<img src="/img/开篇/知识它不进脑.jpg" alt="知识它不进脑" style="zoom:50%;" />



## 题9. [M 30] 理解程序X是算法Y的实现

题：假设算法$Y$为 $$C_1 = \{(Q_1,I_1,\Omega _1,f_1)\}$$ , 计算机程序 $X$为 $C_2 = \{(Q_2,I_2,\Omega _2,f_2)\}$，试表述 “$C_2$模拟$C_1$” 或 “$C_2$是$C_1$的表示”

答：我们可以说 $C_{2}$ 表示 $C_{1},$ 如果有从 $I_{1}$ 到 $I_{2}$ 的函数 $g$,从 $Q_{2}$ 到 $Q_{1}$ 的函数 $h,$ 和从 $Q_{2}$ 到正整数的函数 $j,$ 满足下列条件 :

**a) 如果 $x$ 在 $I_{1}$ 中,则 $h(g(x))=x_{\text {。 }}$** 

对于算法Y中的输入元素 $x$ ，$C_2$中的映射为$x_2 = g(x)$。那么有 $x_2$ 在$Q_1$中的映射为 $x$。即对于算法Y要求的每一个输入，计算机程序X总有一些状态来表示这个算法的输入。每一种计算机状态只能表示一个对应的算法输入。

**b) 如果 $q$ 在 $Q_{2}$ 中,则 $f_{1}(h(q))=h\left(f_{2}^{[j(q)]}(q)\right),$ 其中 $f_{2}^{j(q)}$ 指的是函数 $f_{2}$ 被迭代 $j(q)$ 次。**

为实现算法Y中的一个运算步骤 $f_1()$，计算机程序可能会迭代多次 $f_2()$。 如本节例题8中计算机通过一个循环来实现把所有的c替换成a。

**c) 如果 $q$ 在 $Q_{2}$ 中,则当且仅当 $q$ 在 $\Omega_{2}$ 中时 $h(q)$ 在 $\Omega_{1}$ 中。** 

计算机程序X中的输出状态只会对应到算法Y中的输出状态。



举个例子：

求最大公约数的欧几里得算法可以用这些术语表述如下 : 令 $C_{1}$ 中 $Q$ 为所有单点 $(n),$ 所有有序偶 $(m, n)$ 以及所有有序四元组 $(m, n, r, 1),(m, n, r, 2)$ 以及 $(m, n, p, 3)$ 的集合,其中 $m, n, p$ 是 正整数, $r$ 是一个非负整数。令 $I$ 是所有数偶 $(m, n)$ 的子集,并令 $\Omega$ 是所有单点 $(n)$ 的 子集。定义 $f$ 如下 :
$$
\begin{aligned}
&f((m, n))=(m, n, 0,1) ; \quad f((n))=(n) ;\\
&f((m, n, r, 1))=(m, n, m \text { 除以 } n \text { 的余数 } .2) ;\\
&f((m, n, r, 2))=(n), \text { 如果 } r=0, \quad \text { 否则 }(m, n, r, 3) ;\\
&f((m, n, p, 3))=(n, p, p, 1)
\end{aligned}
$$
那么对于模拟算法的计算机程序，令 $C_{2}$ 有 $I_{2}=\{(m, n)\}, \Omega_{2}=\{(m, n, d) |, Q_{2}=I_{2} \cup \Omega_{2} \cup$ $\{(m, n, a, b, 1)\} \cup$ $\{(m, n, a, b, 2)\}\cup$ $ \{(m, n, a, b, 3)\}\cup$  $ \{(m, n, a, b, 4)\}\cup $ $\{(m, n, a, b, 5)\} $ 

令
$$
\begin{aligned}
&f_{2}((m, n))=(m, n, n, n, 1) \\
&f_{2}((m, n, d))=(m, n, d)  \\
&f_{2}((m, n, a, b,1 )=(m, n, a, b, a \bmod b, 2)\\
&如果\ r=0, f_{2}((m, n, a, b, r, 2))=(m, n, b), \\
&否则\ f_{2}((m, n, a, b,r, 2))=(m, n, a, b, r, 3) \\
 &f_{2}((m, n, a, b, r, 3))=(m, n, b, b, r, 4) \\
 &f_{2}((m, n, a, b, r, 4))=(m, n, a, r, 5) \\
  &f_{2}((m, n, a, b, 5))=f_{2}((m, n, a, b, 1))
\end{aligned}
$$


现在令 
$$
\begin{aligned}
&h((m, n))=g(m, n)=(m, n) \\ &h((m, n, d))=(d)\\ &h((m, n, a, b, 1))=(a, b, 0,1)\\
&h((m, n, a, b, r, 2))=(a, b, r, 2) \\&h((m, n, a, b, r, 3))=(a, b, r, 3) \\ 
&h((m, n, a, b, r, 4))=h(f_{2}((m, n, a, b, r, 4))) \\ &h((m, n, a, b, 5))=(a, b, b, 1) \\
&j((m, n, a, b, r, 3))=j((m, n, a,b, r, 4))=2,否则\ j(q)=1_{\circ}
\end{aligned}
$$
则 $C_{2}$ 表示 $C_{1}$ 



