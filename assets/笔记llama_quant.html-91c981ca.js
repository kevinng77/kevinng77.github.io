import{_ as s,P as r,U as i,Y as a,a1 as e,X as t,aQ as o,E as l}from"./framework-6cee4965.js";const c={},p=a("p",null,"本文导论部署 LLaMa 系列模型常用的几种方案，并作速度测试。包括 Huggingface 自带的 LLM.int8()，AutoGPTQ, GPTQ-for-LLaMa, exllama。",-1),d=a("p",null,"总结来看，对 7B 级别的 LLaMa 系列模型，经过 GPTQ 量化后，在 4090 上可以达到 140+ tokens/s 的推理速度。在 3070 上可以达到 40 tokens/s 的推理速度。",-1),u=a("h2",{id:"lm-int8",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#lm-int8","aria-hidden":"true"},"#"),e(),a("strong",null,"LM.int8()")],-1),h={href:"https://arxiv.org/pdf/2208.07339.pdf",target:"_blank",rel:"noopener noreferrer"},b={href:"https://huggingface.co/docs/transformers/main_classes/quantization",target:"_blank",rel:"noopener noreferrer"},g=a("figure",null,[a("img",{src:"https://pic1.zhimg.com/80/v2-316fd349517183edf3508ddd907f01c4_1440w.png?source=d16d100b",alt:"img",tabindex:"0",loading:"lazy"}),a("figcaption",null,"img")],-1),_={href:"https://huggingface.co/blog/hf-bitsandbytes-integration",target:"_blank",rel:"noopener noreferrer"},f=a("p",null,"结合论文中的实验结果，模型越大，int8() 加速越明显，个人猜测是由于非 outlier 数量变多了，更多的参数进行了 int8 计算，抵消了额外的量化转化时间开销？",-1),m=a("figure",null,[a("img",{src:"https://picx.zhimg.com/80/v2-ffdf642b3e4922782c100ccd5cd9356c_1440w.png?source=d16d100b",alt:"img",tabindex:"0",loading:"lazy"}),a("figcaption",null,"img")],-1),k=a("h2",{id:"gptq",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#gptq","aria-hidden":"true"},"#"),e(),a("strong",null,"GPTQ")],-1),L=a("p",null,"GPTQ: ACCURATE POST-TRAINING QUANTIZATION FOR GENERATIVE PRE-TRAINED TRANSFORMERS",-1),T={href:"https://zhuanlan.zhihu.com/p/629517722",target:"_blank",rel:"noopener noreferrer"},v={href:"https://github.com/oobabooga/text-generation-webui",target:"_blank",rel:"noopener noreferrer"},P={id:"gptq-for-llama",tabindex:"-1"},Q=a("a",{class:"header-anchor",href:"#gptq-for-llama","aria-hidden":"true"},"#",-1),G={href:"https://github.com/qwopqwop200/GPTQ-for-LLaMa/tree/fastest-inference-4bit",target:"_blank",rel:"noopener noreferrer"},M=a("strong",null,"GPTQ-for-LLaMa",-1),x={href:"https://huggingface.co/TheBloke",target:"_blank",rel:"noopener noreferrer"},q={href:"https://huggingface.co/datasets/allenai/c4",target:"_blank",rel:"noopener noreferrer"},A=o(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token assign-left variable">CUDA_VISIBLE_DEVICES</span><span class="token operator">=</span><span class="token number">0</span> python llama.py /models/vicuna-7b c4 <span class="token punctuation">\\</span>
    <span class="token parameter variable">--wbits</span> <span class="token number">4</span> <span class="token punctuation">\\</span>
    --true-sequential <span class="token punctuation">\\</span>
    <span class="token parameter variable">--groupsize</span> <span class="token number">128</span> <span class="token punctuation">\\</span>
    <span class="token parameter variable">--save_safetensors</span> vicuna7b-gptq-4bit-128g.safetensors
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于 GPTQ 是 Layer-Wise Quantization，因此进行量化时对内存和显存要求会少一点。在 4090 测试，最高峰显存占用 7000MiB，整个 GPTQ 量化过程需要 10 分钟。量化后进行 PPL 测试，7b 在没有 arc_order 量化下，c4 的 ppl 大概会在 5-6 左右：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token assign-left variable">CUDA_VISIBLE_DEVICES</span><span class="token operator">=</span><span class="token number">0</span> python llama.py /models/vicuna-7b c4 <span class="token punctuation">\\</span>
    <span class="token parameter variable">--wbits</span> <span class="token number">4</span> <span class="token punctuation">\\</span>
    <span class="token parameter variable">--groupsize</span> <span class="token number">128</span> <span class="token punctuation">\\</span>
    <span class="token parameter variable">--load</span> vicuna7b-gptq-4bit-128g.safetensors <span class="token punctuation">\\</span>
    <span class="token parameter variable">--benchmark</span> <span class="token number">2048</span> <span class="token parameter variable">--check</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,3),B={href:"https://github.com/FranxYao/chain-of-thought-hub/tree/main",target:"_blank",rel:"noopener noreferrer"},w={href:"https://huggingface.co/TheBloke",target:"_blank",rel:"noopener noreferrer"},I=a("p",null,"GPTQ-for-LLaMa 的一些坑：",-1),y={href:"https://huggingface.co/TheBloke/Wizard-Vicuna-30B-Uncensored-GPTQ/discussions/5",target:"_blank",rel:"noopener noreferrer"},z=a("li",null,[a("p",null,"left-padding 问题：目前 GPTQ-for-LLaMa 的所有分支（triton, old-cuda 或 fastest-inference-int4）都存在该问题。如果模型对存在 left-padding 的输入进行预测时候，输出结果是混乱的。这导致了 GPTQ-for-LLaMa 目前无法支持正确的 batch inference。")],-1),U={href:"https://github.com/qwopqwop200/GPTQ-for-LLaMa/issues/89",target:"_blank",rel:"noopener noreferrer"},E={href:"https://github.com/oobabooga/GPTQ-for-LLaMa",target:"_blank",rel:"noopener noreferrer"},C={href:"https://github.com/oobabooga/GPTQ-for-LLaMa",target:"_blank",rel:"noopener noreferrer"},S={href:"https://github.com/oobabooga/text-generation-webui",target:"_blank",rel:"noopener noreferrer"},H={id:"autogptq",tabindex:"-1"},N=a("a",{class:"header-anchor",href:"#autogptq","aria-hidden":"true"},"#",-1),O={href:"https://github.com/PanQiWei/AutoGPTQ",target:"_blank",rel:"noopener noreferrer"},V=a("strong",null,"AutoGPTQ",-1),F={href:"https://github.com/PanQiWei/AutoGPTQ/blob/main/docs/tutorial/01-Quick-Start.md",target:"_blank",rel:"noopener noreferrer"},R={href:"https://github.com/PanQiWei/AutoGPTQ/blob/main/docs/tutorial/02-Advanced-Model-Loading-and-Best-Practice.md",target:"_blank",rel:"noopener noreferrer"},W=o(`<p>AutoGPTQ 可以直接加载 GPTQ-for-LLaMa 的量化模型：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> auto_gptq <span class="token keyword">import</span> AutoGPTQForCausalLM

model <span class="token operator">=</span> AutoGPTQForCausalLM<span class="token punctuation">.</span>from_quantized<span class="token punctuation">(</span>
    model_dir<span class="token punctuation">,</span>     <span class="token comment"># 存放模型的文件路径，里面包含 config.json, tokenizer.json 等模型配置文件</span>
    model_basename<span class="token operator">=</span><span class="token string">&quot;vicuna7b-gptq-4bit-128g.safetensors&quot;</span><span class="token punctuation">,</span>
    use_safetensors<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>
    device<span class="token operator">=</span><span class="token string">&quot;cuda:0&quot;</span><span class="token punctuation">,</span>
    use_triton<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>    <span class="token comment"># Batch inference 时候开启 triton 更快</span>
    max_memory <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token string">&quot;20GIB&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;cpu&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;20GIB&quot;</span><span class="token punctuation">}</span>    <span class="token comment"># </span>
<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>AutoGPTQ 提供了更多的量化加载选项，如是否采用 fused_attention，配置 CPU offload 等。用 AutoGPTQ 加载权重会省去很多不必要的麻烦，如 AutoGPTQ 并没有 GPTQ-for-LLaMa 类似的 left-padding bug，对 Huggingface 其他 LLM 模型的兼容性更好。因此如果做 GPTQ-INT4 batch inference 的话，AutoGPTQ 会是首选。</p><p>但对于 LLaMa 系列模型，AutoGPTQ 的速度会明显慢于 GPTQ-for-LLaMa。在 4090 上测试，GPTQ-for-LLaMa 的推理速度会块差不多 30%。</p>`,4),D={id:"exllama",tabindex:"-1"},j=a("a",{class:"header-anchor",href:"#exllama","aria-hidden":"true"},"#",-1),Y={href:"https://github.com/turboderp/exllama",target:"_blank",rel:"noopener noreferrer"},X=a("strong",null,"exllama",-1),Z={href:"https://github.com/turboderp/exllama",target:"_blank",rel:"noopener noreferrer"},J={href:"https://github.com/oobabooga/text-generation-webui/blob/main/modules/exllama_hf.py",target:"_blank",rel:"noopener noreferrer"},K={id:"gptq-1",tabindex:"-1"},$=a("a",{class:"header-anchor",href:"#gptq-1","aria-hidden":"true"},"#",-1),aa={href:"https://github.com/IST-DASLab/gptq",target:"_blank",rel:"noopener noreferrer"},ea=o('<p>GPTQ 的官方仓库。以上大部分仓库都是基于官方仓库开发的，感谢 GPTQ 的开源，让单卡 24G 显存也能跑上 33B 的大模型。</p><h2 id="推理部署" tabindex="-1"><a class="header-anchor" href="#推理部署" aria-hidden="true">#</a> <strong>推理部署</strong></h2><p>记得在 bert 时代，部署 Pytorch 模型时可能会考虑一些方面，比如动态图转静态图，将模型导出到 onnx，torch jit 等，混合精度推理，量化，剪枝，蒸馏等。对于这些推理加速方案，我们可能需要自己手动应用到训练好的模型上。但在 LLaMa 时代，感受到最大的变化就是，一些开源的框架似乎为你做好了一切，只需要把你训练好的模型权重放上去就能实现比 HF 模型快 n 倍的推理速度。</p><p>以下对比这些推理加速方案：HF 官方 float16（基线）, vllm，llm.int8()，GPTQ-for-LLaMa，AUTOGPTQ，exllama。</p><table><thead><tr><th>Model_name</th><th>tool</th><th>tokens/s</th></tr></thead><tbody><tr><td>vicuna 7b</td><td>float16</td><td>43.27</td></tr><tr><td>vicuna 7b</td><td>load-in-8bit (HF)</td><td>19.21</td></tr><tr><td>vicuna 7b</td><td>load-in-4bit (HF)</td><td>28.25</td></tr><tr><td>vicuna7b-gptq-4bit-128g</td><td>AUTOGPTQ</td><td>79.8</td></tr><tr><td>vicuna7b-gptq-4bit-128g</td><td>GPTQ-for-LLaMa</td><td>80.0</td></tr><tr><td>vicuna7b-gptq-4bit-128g</td><td>exllama</td><td>143.0</td></tr><tr><td>Wizard-Vicuna-13B-GPTQ</td><td>exllama</td><td>90</td></tr><tr><td>Wizard-Vicuna-30B-uncensored-GPTQ</td><td>exllama</td><td>43.1</td></tr><tr><td>Wizard-Vicuna-30B-uncensored-GPTQ</td><td>AUTOGPTQ</td><td>31</td></tr></tbody></table>',5),na={href:"https://github.com/oobabooga/text-generation-webui",target:"_blank",rel:"noopener noreferrer"},ta={href:"https://github.com/qwopqwop200/GPTQ-for-LLaMa#result",target:"_blank",rel:"noopener noreferrer"},oa={href:"https://github.com/turboderp/exllama/tree/master#new-implementation",target:"_blank",rel:"noopener noreferrer"},sa=a("h3",{id:"一些备注",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#一些备注","aria-hidden":"true"},"#"),e(),a("strong",null,"一些备注")],-1),ra={href:"https://discuss.huggingface.co/t/baffling-performance-issue-on-most-nvidia-gpus-with-simple-transformers-pytorch-code/39292/3",target:"_blank",rel:"noopener noreferrer"},ia=a("li",null,"对于 stable diffusion，torch cuda118 能比 torch cuda 117 速度快上 1 倍。但对于 LLaMa 来说，cuda 117 和 118 差别不大。",-1),la=a("li",null,"量化 batch inference 首选 AUTOGPTQ (TRITON)，尽管 AutoGPTQ 速度慢点，但目前版本的 GPTQ-for-LLaMa 存在 left-padding 问题，无法使用 batch inference；batch size = 1 时，首选 exllama 或者 GPTQ-for-LLaMa。",-1),ca=a("li",null,"vllm 部署 fp16 的模型速度也不错（80+ tokens/s），同时也做了内存优化；如果设备资源够的话，可以考虑下 vllm，毕竟采用 GPTQ 还是有一点精度偏差的。",-1),pa=a("li",null,"TheBloke 早期发布的一些模型可能无法加载到 exllama 当中，可以使用最新版本的 GPTQ-for-LLaMa 训练一个新模型。",-1),da=a("li",null,"MAC 部署的话，可以考虑下 llama.cpp。",-1);function ua(ha,ba){const n=l("ExternalLinkIcon");return r(),i("div",null,[p,d,u,a("p",null,[e("来自论文："),a("a",h,[e("LLM.int8(): 8-bit Matrix Multiplication for Transformers at Scale"),t(n)])]),a("p",null,[e("LM.int8() 时 Hugingface 集成的"),a("a",b,[e("量化策略"),t(n)]),e("。能够通过在 .from_pretrain() 时候传递 load_in_8bit 来实现，针对几乎所有的 HF Transformers 模型都有效。大致方法是，在矩阵点积计算过程中， 将其中的 outliers 参数找出来（以行或列为单位），然后用类似 absolute maximum (absmax) quantization 的方法，根据行/列对 Regular 参数做量化处理，outlier 参数仍然做 fp16 计算，最后相加。")]),g,a("p",null,[e("根据 "),a("a",_,[e("huggingface 的博客"),t(n)]),e("， LLM.INT8() 能够再模型性能不影响很多的前提下，让我们能用更少的资源进行 LLM 推理。但 LLM.int8() 普遍的推理速度会比 fp16 慢。博客中指出，对于越小的模型， int8() 会导致更慢的速度。")]),f,m,k,L,a("p",null,[e("使用 GPTQ 量化的模型具有很大的速度优势，与 LLM.int8() 不同，GPTQ 要求对模型进行 post-training quantization，来得到量化权重。GPTQ 主要参考了 Optimal Brain Quanization (OBQ)，对 OBQ 方法进行了提速改进。有网友在 "),a("a",T,[e("文章"),t(n)]),e(" 中对 GPTQ, OBQ, OBS 等量化策略进行了整理，这里就不多赘述了。")]),a("p",null,[e("以下对几个 GPTQ 仓库进行介绍。以下所有测试均在 4090 上进行，模型推理速度采用 "),a("a",v,[e("oobabooga/text-generation-webui"),t(n)]),e(" 提供的 UI。")]),a("h3",P,[Q,e(),a("a",G,[M,e(),t(n)])]),a("p",null,[e("专门针对 LLaMa 提供 GPTQ 量化方案的仓库，如果考虑 GPU 部署 LLaMa 模型的话，GPTQ-for-LLaMa 是十分指的参考的一个工具。像 huggingface.co 上的 "),a("a",x,[e("Thebloke"),t(n)]),e(" 很大部分模型都是采用 GPTQ-for-LLaMa 进行量化的。")]),a("p",null,[e("Post Training Quantization：GPTQ-for-LLaMa 默认采用 "),a("a",q,[e("C4"),t(n)]),e(" 数据集进行量化训练（只采用了 C4 中英文数据的一部分进行量化，而非全部 9TB+的数据）：")]),A,a("p",null,[e("对量化模型在 MMLU 任务上"),a("a",B,[e("测试"),t(n)]),e("，量化后 MMLU 为，于 fp16（46.1）稍微有点差距。")]),a("p",null,[e("Huggingface 上的 "),a("a",w,[e("TheBloke"),t(n)]),e(" 发布的大部分 LLaMa GPTQ 模型，都是通过以上方式（C4 数据集 + wbit 4 + group 128 + no arc_order + true-sequential）量化的。若由于 GPTQ-for-LLaMa 及 transformers 仓库不断更新，Huggingface.co 上发布的模型可能存在无法加载或精度误差等问题，可以考虑重新量化，并通过优化量化数据集、添加 arc_order 等操作来提高量化精度。")]),I,a("ul",null,[a("li",null,[a("p",null,[e("模型加载问题：使用 gptq-for-llama 时，因 transformer 版本不同，可能出现模型加载不上问题。如加载 "),a("a",y,[e("TheBloke/Wizard-Vicuna-30B-Uncensored-GPTQ"),t(n)]),e(" 时，用最新版的 GPTQ-for-LLaMa 就会出现权重于模型 registry 名称不匹配的情况。")])]),z,a("li",null,[a("p",null,[e("经过测试，问题存在于 llama.py 中的 quant.make_quant_attn(model)。使用 quant_attn 能够极大提升模型推理速度。参考这个历史 ISSUE，估计是 position_id 的推理 cache 在 Attention layer 中的配置存在了问题。"),a("a",U,[e("left-padding issue"),t(n)])])]),a("li",null,[a("p",null,[e("GPTQ-for-LLaMa 版本变动大，如果其他仓库有使用 GPTQ-for-LLaMa 依赖的话，需要认真检查以下版本。如 "),a("a",E,[e("obbabooga"),t(n)]),e(" fork 了一个单独的 "),a("a",C,[e("GPTQ-for-LLaMa"),t(n)]),e(" 为 "),a("a",S,[e("oobabooga/text-generation-webui"),t(n)]),e(" 做支持。最新版的 GPTQ-for-LLaMa 在 text-generation-webui 中使用会有 BUG。")])])]),a("h3",H,[N,e(),a("a",O,[V,e(),t(n)])]),a("p",null,[e("AutoGPTQ 使用起来相对容易，它提供了对大多数 Huggingface LLM 模型的量化方案，如 LLaMa 架构系列模型，bloom，moss，falcon，gpt_bigcode 等。（没在支持表中看到 ChatGLM 系列模型）。具体可以参考 官方的 "),a("a",F,[e("快速上手"),t(n)]),e(" 和 "),a("a",R,[e("进阶使用"),t(n)]),e(" 来进行量化模型训练和部署。")]),W,a("h3",D,[j,e(),a("a",Y,[X,e(),t(n)])]),a("p",null,[a("a",Z,[e("exllama"),t(n)]),e(" 为了让 LLaMa 的 GPTQ 系列模型在 4090/3090 Ti 显卡上跑更快，推理平均能达到 140+ tokens/s。当然为了实现那么高的性能加速，exllama 中的模型移除了 HF transformers 模型的大部分依赖，这也导致如果在项目中使用 exllama 模型需要额外的适配工作。text-generation-webui 中对 exllama 进行了 HF 适配，使得我们能够像使用 HF 模型一样使用 exllama，代价是牺牲了一些性能，参考 "),a("a",J,[e("exllama_hf"),t(n)]),e("。")]),a("h3",K,[$,e(),a("a",aa,[e("gptq"),t(n)])]),ea,a("p",null,[e("以上所有测试均在 4090 上进行，模型推理速度采用 "),a("a",na,[e("oobabooga/text-generation-webui"),t(n)]),e(" 提供的 UI。这边只做速度测试，关于精度测试，可以查看 "),a("a",ta,[e("GPT-for-LLaMa result"),t(n)]),e(" 和 "),a("a",oa,[e("exllama results"),t(n)]),e("。")]),sa,a("ol",null,[a("li",null,[e("模型推理的速度受 GPU 即 CPU 的影响最大。有网友指出 "),a("a",ra,[e("link"),t(n)]),e("，同样对于 4090，在 CPU 不同的情况下，7B LLaMa fp16 快的时候有 50 tokens/s，慢的时候能达到 23 tokens/s。")]),ia,la,ca,pa,da])])}const _a=s(c,[["render",ua],["__file","笔记llama_quant.html.vue"]]);export{_a as default};
